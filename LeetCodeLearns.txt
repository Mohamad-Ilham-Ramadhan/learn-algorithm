Lesson learned in solving LeetCode problems:
   - We can use Floyd's hare and tortoise algorithm to detect a cycle in linked list. So we can make time complexity to O(1) instead use a hashmap will be O(n) 
   
   - Use tree and backtracking to find combinations of something like pair of parentheses.
   
   - We can use slow and fast pointers to determine the mid point of a linked list:
      # initial position
      1->2->3->4->5
      s  f
      # 2
      1->2->3->4->5
         s     f
      # 3
      1->2->3->4->5
            s        f
      # 4 both lists are:
      1->2->3  and  4->5
   
   - && operator in if statement is evaluated from left to right. If the left is false then the right will not evaluated.
      var n = null;
      if (n && n.next) <-- false 

      n.next <-- will not be evaluated, even if this is a runtime error.

      so the error will not occur.
   
   - Merge sort: if we have already sorted arrays [[sorted], [sorted], [sorted]], we can just merge them.

   - Conditional matters:
      - in inverting binary tree (recursion):
         - if (root === null || (root.left === null && root.right === null)) return root;
            Runtime: 68 ms, beats 12.5%
         - if (root === null) return root;
            Runtime: 53 ms, beats 85.15%

   - Math.max() vs ternary operator:
      - num1 >= num2 ? num1 : num2; (faster)
      - Math.max(num1, num2); (slower)

- Stuck problems:
   - Subtree of another tree (easy): https://leetcode.com/problems/subtree-of-another-tree 

- Indexing in the queue object so it behaves like an array:
   class Queue {
      constructor() {
         this.queue = {};
         this.head = 0; <----------- INDEX
         this.tail = 0; <----------- INDEX
      }
      enqueue(val) {
         this.queue[this.tail++] = val; <----------- INDEX
      }
      dequeue() {
         const val = this.queue[this.head]; 
         delete this.queue[this.head++]; <----------- INDEX
         return val;
      }
      peak() {
         return this.queue[this.head];
      }
      clear() {
         this.head = 0;
         this.tail = 0;
         this.queue = {};
      }
      size() {
         return this.tail - this.head;
      }
   }

- Swapping two elements in an array:
   - const arr = [1,2,3,4];
   - [ arr[0], arr[3] ] = [ arr[3], arr[0] ];
   - arr -> [4, 2, 3, 1]

- Use negative numbers to mimic max heap if we only have min heap like in the Python language.
   - max heap    min heap           negative min heap
        8         4     --------->     -8
      4   6     8   6                -4  -6
      
      - so we only need to use Math.absolute() to get the max number.
